# hystrix-go 源码分析

## 1. 熔断器
熔断器是 hystrix-go 的核心，它负责监控一个服务的运行状态，当服务运行状态异常时，熔断器会自动开启，从而避免服务的过载。

熔断器的核心思想是：当某个服务的运行状态异常时，不允许其执行请求，而是直接返回错误，这样可以避免服务的过载。

### 1. 熔断器配置
hystrix-go 的熔断器配置分为两类，其中和熔断器自身状态流转相关的配置只有三个：
1. `RequestVolumeThreshold`：10s内请求数达到多少后才进行熔断判断，默认值为 20
2. `SleepWindow`：熔断器打开后，多久允许请求通过，默认值为 5s
3. `ErrorPercentThreshold`：熔断器打开的错误率，默认值为 50%

### 2. 熔断器创建销毁
#### 1. 熔断器对象及初始化
```go
// CircuitBreaker 熔断器对象，
type CircuitBreaker struct {
Name                   string        // 熔断器名称
open                   bool          // 判断熔断器是否打开
forceOpen              bool          // 手动触发熔断器开关
mutex                  *sync.RWMutex // 读写锁
openedOrLastTestedTime int64         // 记录上一次打开熔断器，或者打开状态尝试调用的时间

executorPool *executorPool   // 令牌桶
metrics      *metricExchange // 监控指标
}

var (
circuitBreakersMutex *sync.RWMutex
// 全局熔断器map，存储全部熔断器对象
circuitBreakers map[string]*CircuitBreaker
)

// 使用 init 饿汉式初始化全局map
func init() {
circuitBreakersMutex = &sync.RWMutex{}
circuitBreakers = make(map[string]*CircuitBreaker)
}
```

#### 2. 获取熔断器对象
熔断器典型读多写少，所以使用读写锁来保护熔断器对象  
首先尝试加读锁从全局map中获取熔断器对象，如果获取成功，则直接返回，如果获取失败，则再次加写锁，创建熔断器对象，并返回。  
注意放读锁加写锁后的双重检查，防止多次创建熔断器对象。
```go
// GetCircuit 返回指定name的熔断器对象，存在则直接返回，不存在则创建并返回
func GetCircuit(name string) (*CircuitBreaker, bool, error) {
	// 加读锁尝试从 map 中获取
	circuitBreakersMutex.RLock()
	_, ok := circuitBreakers[name]
	if !ok {
		// 如果 map 中没有，则先释放读锁，然后加写锁创建熔断器对象
		circuitBreakersMutex.RUnlock()
		circuitBreakersMutex.Lock()
		defer circuitBreakersMutex.Unlock()
		// double check 再次检查是否存在
		if cb, ok := circuitBreakers[name]; ok {
			return cb, false, nil
		}
		// 如果不存在，则创建熔断器对象并返回
		circuitBreakers[name] = newCircuitBreaker(name)
	} else {
		defer circuitBreakersMutex.RUnlock()
	}

	return circuitBreakers[name], !ok, nil
}
```

#### 3. 销毁熔断器对象
```go
// Flush 从内存中删除全部熔断器和监控信息
func Flush() {
	// 加写锁
	circuitBreakersMutex.Lock()
	defer circuitBreakersMutex.Unlock()

	// 对于每个熔断器
	for name, cb := range circuitBreakers {
		// 清除监控数据
		cb.metrics.Reset()
		// 清除令牌桶监控数据
		cb.executorPool.Metrics.Reset()
		// 从全局map中移除
		delete(circuitBreakers, name)
	}
}
```

### 3. 熔断器状态流转
常规熔断器存在三个状态：关闭、打开和半打开

在 hystrix-go 中，熔断器对象是`CircuitBreaker`，状态标识为：
- `open` 字段值为 false 时，表示熔断器关闭，此时允许执行 cmd
- `open` 字段值为 true 时，表示熔断器打开，此时不允许执行 cmd
- `open` 字段值为 true && 距离打开时间超过 `SleepWindow` 时，表示熔断器半打开，此时允许少量执行 cmd

状态流转规则如下：
1. 初始化时，熔断器状态为关闭（open）默认为 false：
```go
func newCircuitBreaker(name string) *CircuitBreaker {
	c := &CircuitBreaker{}
	c.Name = name
	c.metrics = newMetricExchange(name)
	c.executorPool = newExecutorPool(name) // 初始化令牌桶
	c.mutex = &sync.RWMutex{}

	return c
}
```
2. 在判断是否允许执行 cmd 时，如果同时满足以下三个条件，打开熔断器：
   1. 熔断器当前状态为关闭（open=false）
   2. 熔断器 10s 内的**请求总数**超过阈值（RequestVolumeThreshold）
   3. 熔断器 10s 内的**错误率**超过阈值（ErrorPercentThreshold）
```go
func (circuit *CircuitBreaker) IsOpen() bool {
	circuit.mutex.RLock()
	o := circuit.forceOpen || circuit.open
	circuit.mutex.RUnlock()

	// 如果熔断器状态为打开，或者设置状态为打开，返回 true
	if o {
		return true
	}

	// 判断 10s 内的并发总数是否超过设置的最大阈值
	if uint64(circuit.metrics.Requests().Sum(time.Now())) < getSettings(circuit.Name).RequestVolumeThreshold {
		return false
	}

	// 此时并发总数已经超过了设置的最大阈值，检查请求错误率是否超过了阈值，如果超过，则打开熔断器
	if !circuit.metrics.IsHealthy(time.Now()) {
		// 打开熔断器，记录此次打开的时间，方便之后进入半打开状态
		circuit.setOpen()
		return true
	}

	return false
}
```
3. hystrix-go 中不存在半打开状态，通过参数`SleepWindow`和`openedOrLastTestedTime`达到尝试请求的目的： 
- 当请求成功，通过后续的上报事件，熔断器状态变为关闭（open=false）
- 当请求失败，`SleepWindow`时间后再次尝试请求
```go
// 半开状态下，偶尔允许单个调用请求
func (circuit *CircuitBreaker) allowSingleTest() bool {
	circuit.mutex.RLock()
	defer circuit.mutex.RUnlock()

	now := time.Now().UnixNano()
	openedOrLastTestedTime := atomic.LoadInt64(&circuit.openedOrLastTestedTime)
	// 当熔断器为打开状态 && 熔断器打开状态持续时间超过阈值
	if circuit.open && now > openedOrLastTestedTime+getSettings(circuit.Name).SleepWindow.Nanoseconds() {
		// 尝试使用 CAS 更新 openedOrLastTestedTime，如果更新成功，返回 true
		swapped := atomic.CompareAndSwapInt64(&circuit.openedOrLastTestedTime, openedOrLastTestedTime, now)
		if swapped {
			log.Printf("hystrix-go: allowing single test to possibly close circuit %v", circuit.Name)
		}
		return swapped
	}

	return false
}

// ReportEvent 收集请求事件，并上报到监控指标
func (circuit *CircuitBreaker) ReportEvent(eventTypes []string, start time.Time, runDuration time.Duration) error {
	if len(eventTypes) == 0 {
		return fmt.Errorf("no event types sent for metrics")
	}

	circuit.mutex.RLock()
	o := circuit.open
	circuit.mutex.RUnlock()
	// 上报的状态事件是 success，且当前熔断器是开启状态，则说明下游服务正常了，可以关闭熔断器了
	if eventTypes[0] == "success" && o {
		// 关闭熔断器
		circuit.setClose()
	}

	...

	return nil
}

```

## 2. 上层调用